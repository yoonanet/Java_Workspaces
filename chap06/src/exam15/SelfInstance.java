package exam15;

class Self {
	private int num; // field
	
	Self(){
		num = 5; // 5의 값으로 초기화
	}
	
	public void useSelf() { // method
		System.out.println("num = " + num);
	}
	
	public static Self makeSelf() {  // class method
		//static선언 의미는 한번이라도 클래스이름의 언급만 되어진다면 static선언 필드나 메서드의 공간이 할당이 된다.
		//여기서 메서드는 호출되어지는 시점에 의미를 가지게 된다. 그 전까지는 이름만 확인하게 된다.
		
		//useSelf(); // error 
		
		Self self = new Self(); 
		//자신의 자료형인 클래스 메소드 안에서 인스턴스 생성하여 자신의 주소값을 잘 보관 -> 가능함.
		//자신의 참조자료형 안에서 언제든지 인스턴스 생성이 가능하고, 그러한 동작들에서 문제가 되지 않는다.
		self.useSelf(); //할당된 영역의 공간에서 메서드 호출이 되어지는 것이다.
		
		return self; //Self의 주소값을 전달.
	}
	//new를 하여 인스턴스를 반환받는 방법만 있는 것이 아니라
	//(+) 클래스 메서드를 생성하여 인스턴스를 반환받는 방법도 있다. 
	
}

public class SelfInstance {
	public static void main(String[] args) {
		Self self = Self.makeSelf(); //참조변수에 Self의 주소값을 self에 잘 보관함
		//인스턴스 생성을 하지 않아도 클래스 이름으로 다이렉트로 메서드 호출이 가능하다.
		//따라서 static을 호출할 때는 Self이름이 선언되어져 있어야 한다.
		
		//자바에서 선언하여 제공해주는 클래스의 경우에서도 
		//메서드 호출에 반환하는 자신의 자료형으로 참조변수가 선언되어 있어서 
		//그것을 선언하게끔 하는 경우라는 것을 떠올려줘야 한다.
		
		
		int num = 0; // 변수를 선언
		//지역변수는 삭제를 해도 초기화를 해주지 않는다.
		//스택영역은 수시로 지우기 때문에 초기화를 하지 않고 이름만 날리기 때문에 쓰레기값이 되는 것이다.
		//***따라서 지역변수를 선언할 때는 초기화의 의무를 가져야 한다.
		//          그래서 정수는 0으로 초기화, 실수는 0.0으로 초기화, boolean은 false로 초기화
		//                 문자열은 ""로 초기화, 문자는 빈스페이스바 초기화
		//***매개변수는 초기화 안해줘도 됨
		//   매개변수는 호출되는 순간 값을 가지고 오기 때문에 가지고 오는 값으로 초기화가 되기 때문이다.
		
		//Heap영역은 new를 하는 순간 메모리 할당_동시에 필드값 초기화 해줌 -> this해서 주솟값 저장 -> 생성자호출에서 전달받은 값으로 초기화
		//           근데 Heap은 영역은 new로 메모리 생성할 때 디폴트로 초기화를 다 해준다. 
		int num1 = 100, num2 = 200;
		
		if (num1 < num2) {
			num = 120;
		}
		
		System.out.println(num); 
		
		//첫번째 변수선언만 하고 출력하라고 할 때 에러남, 
		//스택영역에서 자바가 메모리를 소멸하면 
		//메모리는 영역의 이름은 지워져도 값들은 남아있음 
		//따라서 쓰레기값이 남아있는데 값이 안들어왔다는 에러가 남 
	}
}
