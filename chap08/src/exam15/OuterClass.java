package exam15;

//interface의 활용 3번째: LocalClass에 대한 정의
interface Readable {
	public void read(); //메서드 안에 있는 클래스의 메소드를 추상메소드로 정의한다.
}

class OuterClass {
	private String name;
	
	OuterClass(String name) { this.name = name; }
	
	
	//자료형을 자바가 찾을때는 가까운 동일영역 -> 동일파일 -> 동일패키지로 찾게 됨.
	public Readable createLocalClassInst(final int num) { //이 메서드가 호출될 때 그 안에 클래스를 활성화하겠다는 의미.
	//메서드를 실행하기 전에 "LocalClass" 참조변수 이름만 보면 자바가 모름 그래서 에러남 
	//이때 자바개발자들이 정의한 인터페이스를 이용하면 해결할 수 있다!! 상속의 구조를 활용한다!!	
		
		//메소드 안으로 들어오는 순간 클래스를 만남 -> 클래스를 만나면 메모리할당을 해줄까? 안해준다.
		//클래스의 이름을 보고 끝낸다. 클래스는 메모리 할당을 하려면 new를 꼭!! 해줘야한다는 것을 기억해줘야 한다.
		//자바는 new를 하기 전까지는 클래스에 관심이 없다. new전까지 클래스는 정의만 해준 격.
		class LocalClass implements Readable { 
		//***상속의 관계하에서 오버라이딩 관계를 만들어준다.
			
			public void read() {
				System.out.println("LocalClass read(); " + name);
				System.out.println("num: "+ num); //입력으로 전달받았던 값 -> 매개변수(stack영역에 보관됨)
				//자신의 영역이 끝나면 소멸이 되어야 하는 것인데 이 메소드를 호출하여 실행했을 때 실행이 잘 되고 있음.
				
				//메서드 안에 클래스의 값에서 값을 받을 때는 final int num으로 선언하는 것이 의무였다. -> 매개변수가 소멸되지 않도록
				//처음에 호출되면서 stack영역에 할당이 되지만 클래스 안에서 사용이 되어질 때(new를 하면서 살펴볼 때) 
				//final(상수의 개념)을 붙여주면 지워지지 않는 메모리에 보관을 시켜주도록 할 수 있다.
				
				//7버전부터는 호환성있게 final 제외하고 코드를 작성할 수 있도록 제공을 해주고 있음. 
				//=> 자바내부에서 메소드 안에 클래스에서 매개변수를 사용하게 될때 final을 알아서 적어준다.
				//하지만 직관성을 위해 써주는 것이 좋다!!
			}
		}
		
		Readable localClass = new LocalClass();  //상속의 관계하에서 다형성을 활용한다.
		//메서드가 실행했을 때, 클래스를 실체화시킴 
		//클래스의 참조변수는 => 메서드의 지역변수이다.
		//localClass.read(); //이 의미는 자원이 캐는 메서드를 실행시켰는데 그 종족을 자동으로 생성함.
		//외부에서 접근을 해서 사용자가 캐릭터 사용 기능을 요청하는 것이지 자동으로 생성하게 하는 목적이 아닌 것이다.
		//점수에 따라서 옷을 입힐 수 있다고 가정. 옷을 사기 위해서 아르바이트하도록 하는 게임
		//점수에 쌓이면 그 옷을 자동으로 입히게 하면 안되는 것이다. => 사용자가 호출했을때 실행을 시켜야 하는 것이다.
		
		return localClass; //메서드를 사용하면서 클래스를 사용하고 싶다는 의미이기 때문에 클래스의 주소값을 넘긴다.
		//이때, 에러남 -> 메서드 안으로 들어와야만 클래스의 자료형을 파악할 수 있다. 그래서 자바가 오류를 내주고 있음
	}
	
}


//InnerClass 혹은 Non-static Nested Class (세가지의 형태로 정의할 수 있음) ↓
//- Local Class(지역 클래스): 메서드 안에다가 클래스를 선언할 수 있다는 의미이다. - ***자바 개발자들의 자주 활용하는 요소이다.
//지역 변수: 자신의 영역 안에서 활용이 되어지는 변수로써 stack메모리 영역에 보관된다.

//메소드 안에 클래스를 적용하는 이유는?
//메소드가 호출되지 않으면 그 안에 클래스는 의미가 없다 -> 기능에 영향을 받는 객체인 것이다
//옷을 사기 위한 행위의 조건들을 도달시키고 => 메서드에서 기능들로써 돈을 모음, 
//->클래스를 통해 캐릭터가 옷을 삼(기능을 통해 조건에 도달하면 클래스를 불러내도록 하는 것이다.)
