package exam01;

public class StringInstance {
	public static void main(String[] args) {
		String hello1 = "안녕하세요, 여러분!!!";
		//자바 사이트에서 보면 String이 클래스로 정의가 되어있음.
		//String자체는 자바에서 제공해주는 참조자료형이 맞음 -> 많은 기능들을 통해 제공해줌
		//원칙은 전통적인 방식이 맞는데 사람들이 문자열을 일상적으로 사용하기 때문에 자바가 융통성을 발휘해서
		//new String을 컴파일할 때 자동적으로 작성을 해주는 것이다. 
		
		
		String hello2 = new String("안녕하세요, 여러분!!!"); //전통적인 방식을 사용하더라도 정상적으로 실행이 됨.
		//클래스이면 메모리 할당 요청을 해야 자바가 Heap영역에 메모리를 할당해주게 된다. -> 참조변수에 주솟값이 담기는게 기본적인 방법임.
		//hello2에 주소값이 저장은 된다. 근데 호출했는데 왜 주소값이 호출되지 않는지에 대한 이유는 나중에 설명
		//  --> 상속과 다형성, 오버라이딩 기능이 제공되어 그 부분을 공부한 후 설명 예정.
		
		
		System.out.println(hello1); 
		System.out.println(hello1.length()); //주소값에 접근하여 메소드를 호출.
		System.out.println(hello2.length()); //그 기능들은 Heap영역에 생성이 되기 때문에 .으로 접근이 가능하다.
		//참조변수가 들어가고 있음 -> 원칙으로는 주솟값이 들어가는게 맞다.
		//하지만 사용자가 주솟값을 본다고 도움되는게 없다. 그래서 자바 개발자들은 그 부분을 고려해서
		//담긴 문자열 데이터를 보여주는 것이 효율적이라고 생각을 했음.
		//그래서 자바 개발자들이 주솟값 대신 참조변수에 들어있는 주솟값 대신 그 안에 들어있는 문자열을 출력하도록 만들어줌.
		
		//hello2.length(): hello2에 담긴 문자열의 갯수를 반환해주는 메서드(공백도 포함하여 갯수를 세어줌)
		//메서드에 접근이 가능하다는 것은 hello2가 주솟값을 담고있는게 맞다는 것이다. -> String이 참조자료형이라는 것을 알 수 있음
		//기본자료형처럼 사용할 수 있도록 자바개발자들이 기능을 제공해줌. 그 취지에 맞게 사용하면 됨.
		
		//String을 new를 하여 호출했을 때와 기본자료형처럼 호출했을 때의 내부적인 1가지의 차이점은?
		//new 키워드가 명시되면 동일문자열이든 다른문자열이든 상관하지 않고 무조건 메모리를 할당하고,
		//new를 별도로 지정하지 않으면 문자열이라고 하는 별도의 공간에 만든 다음에 
		//다음 문자열 데이터를 저장할 때 기존 문자열 데이터를 검색한 후
		//같은 문자열이 있으면 이전에 만들었던 동일한 시작주솟값을 반환해주는 것이다. 없으면 공간을 다시 만든다.
		
		//어떤 동작이 더 효율적인 것인가?
		//코드 작성 시 new를 별도로 지정하지 않은 String을 사용하는 것이 동작적인 측면에서 효율적이다.
		//new라는 키워드가 자바 내부적으로 가장 많은 퍼포먼스를 하게 되는 작업이다. 
		//따라서 수행의 속도와 코드에서도 간단하게 처리할 수 있는 아래 방법(String name3 = "홍길동";)이 좋다.
		
		//왜 구분지어서 동작을 시키고 있느냐?
		//퍼포먼스적인 동작때문에 구분짓는 것이다.
			
		String name1 = new String("홍길동");
		String name2 = new String("홍길동");
		String name3 = "홍길동";
		String name4 = "홍길동";
		
		if(name1 == name2) { //두 개의 주소값이 같은지 비교
			System.out.println("동일 인스턴스 참조");
		} else {
			System.out.println("다른 인스턴스 참조");
		}
		
		if(name3 == name4) { //두 개의 주소값이 같은지 비교
			System.out.println("동일 인스턴스 참조");
		} else {
			System.out.println("다른 인스턴스 참조");
		}
		
		int length = "Hello, Java World!!!".length(); //다이렉트 메서드 호출
		//문자열(.)을 하여 접근을 하는 것은 변수 값에 (.)을 하여 접근 하는 것과 다를 것이 없다.
		System.out.println(length);
		
		//위 코드와 System.out.println(hello1.length());와의 차이점
		//참조변수에 담고 메소드를 호출하는 코드와 다이렉트 코드로 호출했을 때는 동작은 같지만 의도에는 차이점이 있다.
		//참조변수의 메모리 영역은 코드를 작성한 이후에 다시 문자열 데이터를 재사용을 하고자 하는 것이고,
		//다이렉트 코드는 문자열 데이터를 한 번만 사용하고 더 이상은 사용하지 않겠다는 의미가 내포되어 있다.
	}
}

//출력 시 문자열이 출력이 되어 문자열끼리의 비교를 하는 것이 아니냐라고 질문을 한다면?
//참조자료형으로 주소값을 저장하는게 맞지만 
//출력하는 순간에 문자열의 참조변수값이 입력되면 
//출력 기능에서 담겨져 있는 데이터를 출력하게끔 구현이 되어 있는 것이다. (헷갈리지 않기)
