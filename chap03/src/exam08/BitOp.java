package exam08;

public class BitOp {

	public static void main(String[] args) { //비트연산에서는 정수값에서만 의미를 가진다. 
		int num1 = 5, num2 = 3;
		int num3 = -1;
		
		System.out.println(num1 & num2); //1이 나옴
		//1이 나오는 이유는?
		//먼저 이진수로 바꿔주면 num1은 00000101, num2는 00000011로 
		//이것을 보면서 비트끼리 연산하는 것이다.
		//이것을 and연산함. 00000001
		// 00000101(5) / 00001000(8) 를 and 연산 => 00000000
		// 00000101(5) / 00001010(10) 를 and 연산 => 00000000
		// 00001100(12) / 00001010(10) 를 and 연산 => 00001000 -> 8
		// 어느 비트에 신호를 넣어주느냐에 초점을 맞추는 것으로 정수값은 크게 의미가 없다. 
		
		System.out.println(num1 | num2); //7 (값이 나오는 부분을 추적해보기: 원인해석)
		//00000101(5)  
		//00000011(3) or연산 => 00000111로 7의 값이 나옴 
		System.out.println(num1 ^ num2); //6
		//00000101(5)  
		//00000011(3) ^연산 => 00000110로 6의 값이 나옴 
		System.out.println(~num3); //0
		//11111111(-1) -> 모든 비트를 반전시키면 00000000로 0이 나옴
	}

}
